
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorial/04_filters/exercises/c_compute-normals.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorial_04_filters_exercises_c_compute-normals.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorial_04_filters_exercises_c_compute-normals.py:


Computing Surface Normals
~~~~~~~~~~~~~~~~~~~~~~~~~


Compute normals on a surface.

.. GENERATED FROM PYTHON SOURCE LINES 8-16

.. code-block:: Python


    import numpy as np

    from pyvista import examples

    mesh = examples.download_topo_global()
    mesh.plot(cmap="gist_earth", show_scalar_bar=False)


.. GENERATED FROM PYTHON SOURCE LINES 18-24

Now we have a surface dataset of the globe loaded - unfortunately, the
dataset shows the globe with a uniform radius which hides topographic relief.
Using :func:`pyvista.PolyData.compute_normals`, we can compute the normal
vectors on the globe at all points in the dataset, then use the values given
in the dataset to warp the surface in the normals direction to create some
exaggerated topographic relief.

.. GENERATED FROM PYTHON SOURCE LINES 24-28

.. code-block:: Python


    # Compute the normals in-place and use them to warp the globe
    ...


.. GENERATED FROM PYTHON SOURCE LINES 29-30

Now use those normals to warp the surface

.. GENERATED FROM PYTHON SOURCE LINES 30-32

.. code-block:: Python

    warp = mesh.warp_by_scalar(factor=0.5e-5)


.. GENERATED FROM PYTHON SOURCE LINES 33-34

And let's see it!

.. GENERATED FROM PYTHON SOURCE LINES 34-37

.. code-block:: Python

    warp.plot(cmap="gist_earth", show_scalar_bar=False)



.. GENERATED FROM PYTHON SOURCE LINES 38-41

We could also use face or cell normals to extract all the faces of a mesh
facing a general direction. In the following snippet, we take a mesh, compute
the normals along its cell faces, and extract the faces that face upward.

.. GENERATED FROM PYTHON SOURCE LINES 41-60

.. code-block:: Python


    mesh = examples.download_nefertiti()
    # Compute normals
    mesh.compute_normals(...)

    # Get list of cell IDs that meet condition
    ids = np.arange(mesh.n_cells)[mesh['Normals'][...] > ...]

    # Extract those cells
    top = mesh.extract_cells(ids)

    cpos = [
        (-834.3184529757553, -918.4677714398535, 236.5468795300025),
        (11.03829376004883, -13.642289291587957, -35.91218884207208),
        (0.19212361465657216, 0.11401076390090074, 0.9747256344254143),
    ]

    top.plot(cpos=cpos, color=True)


.. GENERATED FROM PYTHON SOURCE LINES 61-68

.. raw:: html

    <center>
      <a target="_blank" href="https://colab.research.google.com/github/pyvista/pyvista-tutorial/blob/gh-pages/notebooks/tutorial/04_filters/exercises/c_compute-normals.ipynb">
        <img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/ width="150px">
      </a>
    </center>


.. _sphx_glr_download_tutorial_04_filters_exercises_c_compute-normals.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/pyvista/pyvista-tutorial/gh-pages?urlpath=lab/tree/notebooks/tutorial/04_filters/exercises/c_compute-normals.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: c_compute-normals.ipynb <c_compute-normals.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: c_compute-normals.py <c_compute-normals.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
